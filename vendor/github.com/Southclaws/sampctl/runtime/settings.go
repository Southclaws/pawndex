package runtime

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"strings"

	"github.com/ghodss/yaml"
	"github.com/pkg/errors"

	"github.com/Southclaws/sampctl/print"
	"github.com/Southclaws/sampctl/types"
	"github.com/Southclaws/sampctl/util"
)

var echoMessage = "loading server.cfg generated by sampctl - do not edit this file manually, edit samp.json instead!"

// NewConfigFromEnvironment creates a Config from the given environment which includes a directory
// which is searched for either `samp.json` or `samp.yaml` and environment variable versions of the
// config parameters.
func NewConfigFromEnvironment(dir string) (cfg types.Runtime, err error) {
	cfg, err = ConfigFromDirectory(dir)
	if err != nil {
		return
	}

	// Environment variables override samp.json
	LoadEnvironmentVariables(&cfg)

	cfg.Platform = runtime.GOOS

	if cfg.Version == "" {
		cfg.Version = "0.3.7"
	}

	if cfg.Endpoint == "" {
		cfg.Endpoint = "http://files.sa-mp.com"
	}

	return
}

// ConfigFromDirectory creates a config from a directory by searching for a JSON or YAML file to
// read settings from. If both exist, the JSON file takes precedence.
func ConfigFromDirectory(dir string) (cfg types.Runtime, err error) {
	jsonFile := filepath.Join(dir, "samp.json")
	if util.Exists(jsonFile) {
		cfg, err = ConfigFromJSON(jsonFile)
		if err != nil {
			return
		}
		cfg.WorkingDir = dir
		return
	}

	yamlFile := filepath.Join(dir, "samp.yaml")
	if util.Exists(yamlFile) {
		cfg, err = ConfigFromYAML(yamlFile)
		if err != nil {
			return
		}
		cfg.WorkingDir = dir
		return
	}

	err = errors.New("directory does not contain a samp.json or samp.yaml file")

	return
}

// ConfigFromJSON creates a config from a JSON file
func ConfigFromJSON(file string) (cfg types.Runtime, err error) {
	var contents []byte
	contents, err = ioutil.ReadFile(file)
	if err != nil {
		err = errors.Wrap(err, "failed to read samp.json")
		return
	}

	err = json.Unmarshal(contents, &cfg)
	if err != nil {
		err = errors.Wrap(err, "failed to unmarshal samp.json")
		return
	}

	return
}

// ConfigFromYAML creates a config from a YAML file
func ConfigFromYAML(file string) (cfg types.Runtime, err error) {
	var contents []byte
	contents, err = ioutil.ReadFile(file)
	if err != nil {
		err = errors.Wrap(err, "failed to read samp.json")
		return
	}

	err = yaml.Unmarshal(contents, &cfg)
	if err != nil {
		err = errors.Wrap(err, "failed to unmarshal samp.json")
		return
	}

	return
}

// LoadEnvironmentVariables loads Config fields from environment variables - the variable names are
// simply the `json` tag names uppercased and prefixed with `SAMP_`
func LoadEnvironmentVariables(cfg *types.Runtime) {
	v := reflect.ValueOf(cfg).Elem()
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		fieldval := v.Field(i)
		stype := t.Field(i)

		if !fieldval.CanSet() {
			continue
		}

		name := "SAMP_" + strings.ToUpper(strings.Split(t.Field(i).Tag.Get("json"), ",")[0])

		value, ok := os.LookupEnv(name)
		if !ok {
			continue
		}

		switch stype.Type.String() {
		case "*string":
			if fieldval.IsNil() {
				v := reflect.ValueOf(value)
				fieldval.Set(reflect.New(v.Type()))
			}
			fieldval.Elem().SetString(value)

		case "[]string":
			// todo: allow filterscripts via env vars
			print.Warn("cannot set filterscripts via environment variables yet")

		case "[]runtime.Plugin":
			// todo: plugins via env vars
			print.Warn("cannot set plugins via environment variables yet")

		case "*bool":
			valueAsBool, err := strconv.ParseBool(value)
			if err != nil {
				print.Warn("environment variable", stype.Name, "could not interpret value", value, "as boolean:", err)
				continue
			}
			if fieldval.IsNil() {
				v := reflect.ValueOf(valueAsBool)
				fieldval.Set(reflect.New(v.Type()))
			}
			fieldval.Elem().SetBool(valueAsBool)

		case "*int":
			valueAsInt, err := strconv.Atoi(value)
			if err != nil {
				print.Warn("environment variable", stype.Name, "could not interpret value", value, "as integer:", err)
				continue
			}
			if fieldval.IsNil() {
				v := reflect.ValueOf(valueAsInt)
				fieldval.Set(reflect.New(v.Type()))
			}
			fieldval.Elem().SetInt(int64(valueAsInt))

		case "*float32":
			valueAsFloat, err := strconv.ParseFloat(value, 64)
			if err != nil {
				print.Warn("environment variable", stype.Name, "could not interpret value", value, "as float:", err)
				continue
			}
			if fieldval.IsNil() {
				v := reflect.ValueOf(valueAsFloat)
				fieldval.Set(reflect.New(v.Type()))
			}
			fieldval.Elem().SetFloat(valueAsFloat)
		default:
			panic(fmt.Sprintf("unknown kind '%s'", stype.Type.String()))
		}
	}
}
